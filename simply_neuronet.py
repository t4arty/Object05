# Давайте сначала начнем со стандартной нейронной сети на питоне. Сеть будет состоять из трех слоев: 
# входного, скрытого и выходного слоя. Каждый слой будет состоять из нескольких нейронов. 
# Входной слой получает данные и передает их дальше. 
# Скрытый слой использует полученные данные и производит некоторые вычисления. 
# Выходной слой выдает ответ на входные данные. 
# Давайте посмотрим, как это будет выглядеть на питоне: 

import numpy as np

# Входные данные
X = np.array([[0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1]])

# Выходные данные
y = np.array([[0, 1, 1, 0]]).T

# Размерность наших слоев
input_size = 3 
hidden_size = 4 
output_size = 1

# Инициализируем веса
W1 = np.random.randn(input_size, hidden_size) 
W2 = np.random.randn(hidden_size, output_size)

# Задаем скорость обучения
learning_rate = 0.1

# Шаг обучения
for epoch in range(20000): 
  # Прямое распространение
  Z1 = np.dot(X, W1) 
  A1 = np.tanh(Z1) 
  Z2 = np.dot(A1, W2) 
  A2 = 1/(1 + np.exp(-Z2)) 
  
  # Обратное распространение
  error = y - A2 
  dZ2 = error * (A2 * (1 - A2)) 
  dW2 = np.dot(A1.T, dZ2) 
  dZ1 = np.dot(dZ2, W2.T) * (1 - np.power(A1, 2)) 
  dW1 = np.dot(X.T, dZ1) 
  
  # Обновляем веса 
  W1 += learning_rate * dW1 
  W2 += learning_rate * dW2

# Проверка правильности
A2 = 1/(1 + np.exp(-np.dot(np.tanh(np.dot(X, W1)), W2)))
print(A2)
